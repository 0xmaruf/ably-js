(function() {

/* declarations to ensure these variables do not go into global scope */
var TError, TData, TPresence, TMessage, TChannelMessage, TProtocolMessage;
var clientmessage_types = {
	TError: TError,
	TData: TData,
	TPresence: TPresence,
	TMessage: TMessage,
	TChannelMessage: TChannelMessage,
	TProtocolMessage: TProtocolMessage
};

//
// Autogenerated by Thrift Compiler (0.9.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


TAction = {
'HEARTBEAT' : 0,
'ACK' : 1,
'NACK' : 2,
'CONNECT' : 3,
'CONNECTED' : 4,
'DISCONNECT' : 5,
'DISCONNECTED' : 6,
'CLOSE' : 7,
'CLOSED' : 8,
'ERROR' : 9,
'ATTACH' : 10,
'ATTACHED' : 11,
'DETACH' : 12,
'DETACHED' : 13,
'PRESENCE' : 14,
'MESSAGE' : 15
};
TType = {
'NONE' : 0,
'TRUE' : 1,
'FALSE' : 2,
'INT32' : 3,
'INT64' : 4,
'DOUBLE' : 5,
'STRING' : 6,
'BUFFER' : 7,
'JSONARRAY' : 8,
'JSONOBJECT' : 9
};
TFlags = {
'SYNC_TIME' : 0
};
TPresenceState = {
'ENTER' : 0,
'LEAVE' : 1,
'UPDATE' : 2
};
TError = function(args) {
  this.statusCode = undefined;
  this.code = undefined;
  this.message = undefined;
  if (args) {
    if (args.statusCode !== undefined) {
      this.statusCode = args.statusCode;
    }
    if (args.code !== undefined) {
      this.code = args.code;
    }
    if (args.message !== undefined) {
      this.message = args.message;
    }
  }
};
TError.prototype = {};
TError.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I16) {
        this.statusCode = input.readI16();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.code = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.message = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TError.prototype.write = function(output) {
  output.writeStructBegin('TError');
  if (this.statusCode !== undefined) {
    output.writeFieldBegin('statusCode', Thrift.Type.I16, 1);
    output.writeI16(this.statusCode);
    output.writeFieldEnd();
  }
  if (this.code !== undefined) {
    output.writeFieldBegin('code', Thrift.Type.I32, 2);
    output.writeI32(this.code);
    output.writeFieldEnd();
  }
  if (this.message !== undefined) {
    output.writeFieldBegin('message', Thrift.Type.STRING, 3);
    output.writeString(this.message);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

TData = function(args) {
  this.type = undefined;
  this.i32Data = undefined;
  this.i64Data = undefined;
  this.doubleData = undefined;
  this.stringData = undefined;
  this.binaryData = undefined;
  this.cipherData = undefined;
  if (args) {
    if (args.type !== undefined) {
      this.type = args.type;
    }
    if (args.i32Data !== undefined) {
      this.i32Data = args.i32Data;
    }
    if (args.i64Data !== undefined) {
      this.i64Data = args.i64Data;
    }
    if (args.doubleData !== undefined) {
      this.doubleData = args.doubleData;
    }
    if (args.stringData !== undefined) {
      this.stringData = args.stringData;
    }
    if (args.binaryData !== undefined) {
      this.binaryData = args.binaryData;
    }
    if (args.cipherData !== undefined) {
      this.cipherData = args.cipherData;
    }
  }
};
TData.prototype = {};
TData.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.type = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.i32Data = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.i64Data = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.DOUBLE) {
        this.doubleData = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRING) {
        this.stringData = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.STRING) {
        this.binaryData = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.STRING) {
        this.cipherData = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TData.prototype.write = function(output) {
  output.writeStructBegin('TData');
  if (this.type !== undefined) {
    output.writeFieldBegin('type', Thrift.Type.I32, 1);
    output.writeI32(this.type);
    output.writeFieldEnd();
  }
  if (this.i32Data !== undefined) {
    output.writeFieldBegin('i32Data', Thrift.Type.I32, 2);
    output.writeI32(this.i32Data);
    output.writeFieldEnd();
  }
  if (this.i64Data !== undefined) {
    output.writeFieldBegin('i64Data', Thrift.Type.I64, 3);
    output.writeI64(this.i64Data);
    output.writeFieldEnd();
  }
  if (this.doubleData !== undefined) {
    output.writeFieldBegin('doubleData', Thrift.Type.DOUBLE, 4);
    output.writeDouble(this.doubleData);
    output.writeFieldEnd();
  }
  if (this.stringData !== undefined) {
    output.writeFieldBegin('stringData', Thrift.Type.STRING, 5);
    output.writeString(this.stringData);
    output.writeFieldEnd();
  }
  if (this.binaryData !== undefined) {
    output.writeFieldBegin('binaryData', Thrift.Type.STRING, 6);
    output.writeBinary(this.binaryData);
    output.writeFieldEnd();
  }
  if (this.cipherData !== undefined) {
    output.writeFieldBegin('cipherData', Thrift.Type.STRING, 7);
    output.writeBinary(this.cipherData);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

TPresence = function(args) {
  this.state = undefined;
  this.clientId = undefined;
  this.clientData = undefined;
  this.memberId = undefined;
  this.inheritMemberId = undefined;
  this.connectionId = undefined;
  this.instanceId = undefined;
  if (args) {
    if (args.state !== undefined) {
      this.state = args.state;
    }
    if (args.clientId !== undefined) {
      this.clientId = args.clientId;
    }
    if (args.clientData !== undefined) {
      this.clientData = args.clientData;
    }
    if (args.memberId !== undefined) {
      this.memberId = args.memberId;
    }
    if (args.inheritMemberId !== undefined) {
      this.inheritMemberId = args.inheritMemberId;
    }
    if (args.connectionId !== undefined) {
      this.connectionId = args.connectionId;
    }
    if (args.instanceId !== undefined) {
      this.instanceId = args.instanceId;
    }
  }
};
TPresence.prototype = {};
TPresence.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.state = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.clientId = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.clientData = new TData();
        this.clientData.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.memberId = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRING) {
        this.inheritMemberId = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.STRING) {
        this.connectionId = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.STRING) {
        this.instanceId = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TPresence.prototype.write = function(output) {
  output.writeStructBegin('TPresence');
  if (this.state !== undefined) {
    output.writeFieldBegin('state', Thrift.Type.I32, 1);
    output.writeI32(this.state);
    output.writeFieldEnd();
  }
  if (this.clientId !== undefined) {
    output.writeFieldBegin('clientId', Thrift.Type.STRING, 2);
    output.writeString(this.clientId);
    output.writeFieldEnd();
  }
  if (this.clientData !== undefined) {
    output.writeFieldBegin('clientData', Thrift.Type.STRUCT, 3);
    this.clientData.write(output);
    output.writeFieldEnd();
  }
  if (this.memberId !== undefined) {
    output.writeFieldBegin('memberId', Thrift.Type.STRING, 4);
    output.writeString(this.memberId);
    output.writeFieldEnd();
  }
  if (this.inheritMemberId !== undefined) {
    output.writeFieldBegin('inheritMemberId', Thrift.Type.STRING, 5);
    output.writeString(this.inheritMemberId);
    output.writeFieldEnd();
  }
  if (this.connectionId !== undefined) {
    output.writeFieldBegin('connectionId', Thrift.Type.STRING, 6);
    output.writeString(this.connectionId);
    output.writeFieldEnd();
  }
  if (this.instanceId !== undefined) {
    output.writeFieldBegin('instanceId', Thrift.Type.STRING, 7);
    output.writeString(this.instanceId);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

TPresenceArray = function(args) {
  this.items = undefined;
  if (args) {
    if (args.items !== undefined) {
      this.items = args.items;
    }
  }
};
TPresenceArray.prototype = {};
TPresenceArray.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        var _size0 = 0;
        var _rtmp34;
        this.items = [];
        var _etype3 = 0;
        _rtmp34 = input.readListBegin();
        _etype3 = _rtmp34.etype;
        _size0 = _rtmp34.size;
        for (var _i5 = 0; _i5 < _size0; ++_i5)
        {
          var elem6 = null;
          elem6 = new TPresence();
          elem6.read(input);
          this.items.push(elem6);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TPresenceArray.prototype.write = function(output) {
  output.writeStructBegin('TPresenceArray');
  if (this.items !== undefined) {
    output.writeFieldBegin('items', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRUCT, this.items.length);
    for (var iter7 in this.items)
    {
      if (this.items.hasOwnProperty(iter7))
      {
        iter7 = this.items[iter7];
        iter7.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

TMessage = function(args) {
  this.name = undefined;
  this.clientId = undefined;
  this.timestamp = undefined;
  this.data = undefined;
  this.tags = undefined;
  if (args) {
    if (args.name !== undefined) {
      this.name = args.name;
    }
    if (args.clientId !== undefined) {
      this.clientId = args.clientId;
    }
    if (args.timestamp !== undefined) {
      this.timestamp = args.timestamp;
    }
    if (args.data !== undefined) {
      this.data = args.data;
    }
    if (args.tags !== undefined) {
      this.tags = args.tags;
    }
  }
};
TMessage.prototype = {};
TMessage.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.clientId = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.timestamp = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.data = new TData();
        this.data.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.LIST) {
        var _size8 = 0;
        var _rtmp312;
        this.tags = [];
        var _etype11 = 0;
        _rtmp312 = input.readListBegin();
        _etype11 = _rtmp312.etype;
        _size8 = _rtmp312.size;
        for (var _i13 = 0; _i13 < _size8; ++_i13)
        {
          var elem14 = null;
          elem14 = input.readString();
          this.tags.push(elem14);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TMessage.prototype.write = function(output) {
  output.writeStructBegin('TMessage');
  if (this.name !== undefined) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 1);
    output.writeString(this.name);
    output.writeFieldEnd();
  }
  if (this.clientId !== undefined) {
    output.writeFieldBegin('clientId', Thrift.Type.STRING, 2);
    output.writeString(this.clientId);
    output.writeFieldEnd();
  }
  if (this.timestamp !== undefined) {
    output.writeFieldBegin('timestamp', Thrift.Type.I64, 3);
    output.writeI64(this.timestamp);
    output.writeFieldEnd();
  }
  if (this.data !== undefined) {
    output.writeFieldBegin('data', Thrift.Type.STRUCT, 4);
    this.data.write(output);
    output.writeFieldEnd();
  }
  if (this.tags !== undefined) {
    output.writeFieldBegin('tags', Thrift.Type.LIST, 5);
    output.writeListBegin(Thrift.Type.STRING, this.tags.length);
    for (var iter15 in this.tags)
    {
      if (this.tags.hasOwnProperty(iter15))
      {
        iter15 = this.tags[iter15];
        output.writeString(iter15);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

TMessageArray = function(args) {
  this.items = undefined;
  if (args) {
    if (args.items !== undefined) {
      this.items = args.items;
    }
  }
};
TMessageArray.prototype = {};
TMessageArray.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        var _size16 = 0;
        var _rtmp320;
        this.items = [];
        var _etype19 = 0;
        _rtmp320 = input.readListBegin();
        _etype19 = _rtmp320.etype;
        _size16 = _rtmp320.size;
        for (var _i21 = 0; _i21 < _size16; ++_i21)
        {
          var elem22 = null;
          elem22 = new TMessage();
          elem22.read(input);
          this.items.push(elem22);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TMessageArray.prototype.write = function(output) {
  output.writeStructBegin('TMessageArray');
  if (this.items !== undefined) {
    output.writeFieldBegin('items', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRUCT, this.items.length);
    for (var iter23 in this.items)
    {
      if (this.items.hasOwnProperty(iter23))
      {
        iter23 = this.items[iter23];
        iter23.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

TProtocolMessage = function(args) {
  this.action = undefined;
  this.flags = undefined;
  this.count = undefined;
  this.error = undefined;
  this.applicationId = undefined;
  this.connectionId = undefined;
  this.connectionSerial = undefined;
  this.channel = undefined;
  this.channelSerial = undefined;
  this.msgSerial = undefined;
  this.timestamp = undefined;
  this.messages = undefined;
  this.presence = undefined;
  if (args) {
    if (args.action !== undefined) {
      this.action = args.action;
    }
    if (args.flags !== undefined) {
      this.flags = args.flags;
    }
    if (args.count !== undefined) {
      this.count = args.count;
    }
    if (args.error !== undefined) {
      this.error = args.error;
    }
    if (args.applicationId !== undefined) {
      this.applicationId = args.applicationId;
    }
    if (args.connectionId !== undefined) {
      this.connectionId = args.connectionId;
    }
    if (args.connectionSerial !== undefined) {
      this.connectionSerial = args.connectionSerial;
    }
    if (args.channel !== undefined) {
      this.channel = args.channel;
    }
    if (args.channelSerial !== undefined) {
      this.channelSerial = args.channelSerial;
    }
    if (args.msgSerial !== undefined) {
      this.msgSerial = args.msgSerial;
    }
    if (args.timestamp !== undefined) {
      this.timestamp = args.timestamp;
    }
    if (args.messages !== undefined) {
      this.messages = args.messages;
    }
    if (args.presence !== undefined) {
      this.presence = args.presence;
    }
  }
};
TProtocolMessage.prototype = {};
TProtocolMessage.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.action = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.BYTE) {
        this.flags = input.readByte();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.count = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.error = new TError();
        this.error.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRING) {
        this.applicationId = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.STRING) {
        this.connectionId = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.I64) {
        this.connectionSerial = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.STRING) {
        this.channel = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 9:
      if (ftype == Thrift.Type.STRING) {
        this.channelSerial = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 10:
      if (ftype == Thrift.Type.I64) {
        this.msgSerial = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 11:
      if (ftype == Thrift.Type.I64) {
        this.timestamp = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 12:
      if (ftype == Thrift.Type.LIST) {
        var _size24 = 0;
        var _rtmp328;
        this.messages = [];
        var _etype27 = 0;
        _rtmp328 = input.readListBegin();
        _etype27 = _rtmp328.etype;
        _size24 = _rtmp328.size;
        for (var _i29 = 0; _i29 < _size24; ++_i29)
        {
          var elem30 = null;
          elem30 = new TMessage();
          elem30.read(input);
          this.messages.push(elem30);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 13:
      if (ftype == Thrift.Type.LIST) {
        var _size31 = 0;
        var _rtmp335;
        this.presence = [];
        var _etype34 = 0;
        _rtmp335 = input.readListBegin();
        _etype34 = _rtmp335.etype;
        _size31 = _rtmp335.size;
        for (var _i36 = 0; _i36 < _size31; ++_i36)
        {
          var elem37 = null;
          elem37 = new TPresence();
          elem37.read(input);
          this.presence.push(elem37);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TProtocolMessage.prototype.write = function(output) {
  output.writeStructBegin('TProtocolMessage');
  if (this.action !== undefined) {
    output.writeFieldBegin('action', Thrift.Type.I32, 1);
    output.writeI32(this.action);
    output.writeFieldEnd();
  }
  if (this.flags !== undefined) {
    output.writeFieldBegin('flags', Thrift.Type.BYTE, 2);
    output.writeByte(this.flags);
    output.writeFieldEnd();
  }
  if (this.count !== undefined) {
    output.writeFieldBegin('count', Thrift.Type.I32, 3);
    output.writeI32(this.count);
    output.writeFieldEnd();
  }
  if (this.error !== undefined) {
    output.writeFieldBegin('error', Thrift.Type.STRUCT, 4);
    this.error.write(output);
    output.writeFieldEnd();
  }
  if (this.applicationId !== undefined) {
    output.writeFieldBegin('applicationId', Thrift.Type.STRING, 5);
    output.writeString(this.applicationId);
    output.writeFieldEnd();
  }
  if (this.connectionId !== undefined) {
    output.writeFieldBegin('connectionId', Thrift.Type.STRING, 6);
    output.writeString(this.connectionId);
    output.writeFieldEnd();
  }
  if (this.connectionSerial !== undefined) {
    output.writeFieldBegin('connectionSerial', Thrift.Type.I64, 7);
    output.writeI64(this.connectionSerial);
    output.writeFieldEnd();
  }
  if (this.channel !== undefined) {
    output.writeFieldBegin('channel', Thrift.Type.STRING, 8);
    output.writeString(this.channel);
    output.writeFieldEnd();
  }
  if (this.channelSerial !== undefined) {
    output.writeFieldBegin('channelSerial', Thrift.Type.STRING, 9);
    output.writeString(this.channelSerial);
    output.writeFieldEnd();
  }
  if (this.msgSerial !== undefined) {
    output.writeFieldBegin('msgSerial', Thrift.Type.I64, 10);
    output.writeI64(this.msgSerial);
    output.writeFieldEnd();
  }
  if (this.timestamp !== undefined) {
    output.writeFieldBegin('timestamp', Thrift.Type.I64, 11);
    output.writeI64(this.timestamp);
    output.writeFieldEnd();
  }
  if (this.messages !== undefined) {
    output.writeFieldBegin('messages', Thrift.Type.LIST, 12);
    output.writeListBegin(Thrift.Type.STRUCT, this.messages.length);
    for (var iter38 in this.messages)
    {
      if (this.messages.hasOwnProperty(iter38))
      {
        iter38 = this.messages[iter38];
        iter38.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.presence !== undefined) {
    output.writeFieldBegin('presence', Thrift.Type.LIST, 13);
    output.writeListBegin(Thrift.Type.STRUCT, this.presence.length);
    for (var iter39 in this.presence)
    {
      if (this.presence.hasOwnProperty(iter39))
      {
        iter39 = this.presence[iter39];
        iter39.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

TMessageBundle = function(args) {
  this.items = undefined;
  if (args) {
    if (args.items !== undefined) {
      this.items = args.items;
    }
  }
};
TMessageBundle.prototype = {};
TMessageBundle.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        var _size40 = 0;
        var _rtmp344;
        this.items = [];
        var _etype43 = 0;
        _rtmp344 = input.readListBegin();
        _etype43 = _rtmp344.etype;
        _size40 = _rtmp344.size;
        for (var _i45 = 0; _i45 < _size40; ++_i45)
        {
          var elem46 = null;
          elem46 = new TProtocolMessage();
          elem46.read(input);
          this.items.push(elem46);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TMessageBundle.prototype.write = function(output) {
  output.writeStructBegin('TMessageBundle');
  if (this.items !== undefined) {
    output.writeFieldBegin('items', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRUCT, this.items.length);
    for (var iter47 in this.items)
    {
      if (this.items.hasOwnProperty(iter47))
      {
        iter47 = this.items[iter47];
        iter47.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

SMessageCount = function(args) {
  this.count = undefined;
  this.data = undefined;
  if (args) {
    if (args.count !== undefined) {
      this.count = args.count;
    }
    if (args.data !== undefined) {
      this.data = args.data;
    }
  }
};
SMessageCount.prototype = {};
SMessageCount.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.DOUBLE) {
        this.count = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.DOUBLE) {
        this.data = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SMessageCount.prototype.write = function(output) {
  output.writeStructBegin('SMessageCount');
  if (this.count !== undefined) {
    output.writeFieldBegin('count', Thrift.Type.DOUBLE, 1);
    output.writeDouble(this.count);
    output.writeFieldEnd();
  }
  if (this.data !== undefined) {
    output.writeFieldBegin('data', Thrift.Type.DOUBLE, 2);
    output.writeDouble(this.data);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

SMessageTypes = function(args) {
  this.all = undefined;
  this.messages = undefined;
  this.presence = undefined;
  if (args) {
    if (args.all !== undefined) {
      this.all = args.all;
    }
    if (args.messages !== undefined) {
      this.messages = args.messages;
    }
    if (args.presence !== undefined) {
      this.presence = args.presence;
    }
  }
};
SMessageTypes.prototype = {};
SMessageTypes.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.all = new SMessageCount();
        this.all.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.messages = new SMessageCount();
        this.messages.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.presence = new SMessageCount();
        this.presence.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SMessageTypes.prototype.write = function(output) {
  output.writeStructBegin('SMessageTypes');
  if (this.all !== undefined) {
    output.writeFieldBegin('all', Thrift.Type.STRUCT, 1);
    this.all.write(output);
    output.writeFieldEnd();
  }
  if (this.messages !== undefined) {
    output.writeFieldBegin('messages', Thrift.Type.STRUCT, 2);
    this.messages.write(output);
    output.writeFieldEnd();
  }
  if (this.presence !== undefined) {
    output.writeFieldBegin('presence', Thrift.Type.STRUCT, 3);
    this.presence.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

SResourceCount = function(args) {
  this.opened = undefined;
  this.peak = undefined;
  this.mean = undefined;
  this.min = undefined;
  this.refused = undefined;
  this.sample_count = undefined;
  this.sample_sum = undefined;
  if (args) {
    if (args.opened !== undefined) {
      this.opened = args.opened;
    }
    if (args.peak !== undefined) {
      this.peak = args.peak;
    }
    if (args.mean !== undefined) {
      this.mean = args.mean;
    }
    if (args.min !== undefined) {
      this.min = args.min;
    }
    if (args.refused !== undefined) {
      this.refused = args.refused;
    }
    if (args.sample_count !== undefined) {
      this.sample_count = args.sample_count;
    }
    if (args.sample_sum !== undefined) {
      this.sample_sum = args.sample_sum;
    }
  }
};
SResourceCount.prototype = {};
SResourceCount.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.DOUBLE) {
        this.opened = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.DOUBLE) {
        this.peak = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.DOUBLE) {
        this.mean = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.DOUBLE) {
        this.min = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.DOUBLE) {
        this.refused = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 10:
      if (ftype == Thrift.Type.DOUBLE) {
        this.sample_count = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 11:
      if (ftype == Thrift.Type.DOUBLE) {
        this.sample_sum = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SResourceCount.prototype.write = function(output) {
  output.writeStructBegin('SResourceCount');
  if (this.opened !== undefined) {
    output.writeFieldBegin('opened', Thrift.Type.DOUBLE, 1);
    output.writeDouble(this.opened);
    output.writeFieldEnd();
  }
  if (this.peak !== undefined) {
    output.writeFieldBegin('peak', Thrift.Type.DOUBLE, 2);
    output.writeDouble(this.peak);
    output.writeFieldEnd();
  }
  if (this.mean !== undefined) {
    output.writeFieldBegin('mean', Thrift.Type.DOUBLE, 3);
    output.writeDouble(this.mean);
    output.writeFieldEnd();
  }
  if (this.min !== undefined) {
    output.writeFieldBegin('min', Thrift.Type.DOUBLE, 4);
    output.writeDouble(this.min);
    output.writeFieldEnd();
  }
  if (this.refused !== undefined) {
    output.writeFieldBegin('refused', Thrift.Type.DOUBLE, 5);
    output.writeDouble(this.refused);
    output.writeFieldEnd();
  }
  if (this.sample_count !== undefined) {
    output.writeFieldBegin('sample_count', Thrift.Type.DOUBLE, 10);
    output.writeDouble(this.sample_count);
    output.writeFieldEnd();
  }
  if (this.sample_sum !== undefined) {
    output.writeFieldBegin('sample_sum', Thrift.Type.DOUBLE, 11);
    output.writeDouble(this.sample_sum);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

SConnectionTypes = function(args) {
  this.all = undefined;
  this.plain = undefined;
  this.tls = undefined;
  if (args) {
    if (args.all !== undefined) {
      this.all = args.all;
    }
    if (args.plain !== undefined) {
      this.plain = args.plain;
    }
    if (args.tls !== undefined) {
      this.tls = args.tls;
    }
  }
};
SConnectionTypes.prototype = {};
SConnectionTypes.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.all = new SResourceCount();
        this.all.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.plain = new SResourceCount();
        this.plain.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.tls = new SResourceCount();
        this.tls.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SConnectionTypes.prototype.write = function(output) {
  output.writeStructBegin('SConnectionTypes');
  if (this.all !== undefined) {
    output.writeFieldBegin('all', Thrift.Type.STRUCT, 1);
    this.all.write(output);
    output.writeFieldEnd();
  }
  if (this.plain !== undefined) {
    output.writeFieldBegin('plain', Thrift.Type.STRUCT, 2);
    this.plain.write(output);
    output.writeFieldEnd();
  }
  if (this.tls !== undefined) {
    output.writeFieldBegin('tls', Thrift.Type.STRUCT, 3);
    this.tls.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

SMessageTraffic = function(args) {
  this.all = undefined;
  this.realtime = undefined;
  this.rest = undefined;
  this.push = undefined;
  this.httpStream = undefined;
  if (args) {
    if (args.all !== undefined) {
      this.all = args.all;
    }
    if (args.realtime !== undefined) {
      this.realtime = args.realtime;
    }
    if (args.rest !== undefined) {
      this.rest = args.rest;
    }
    if (args.push !== undefined) {
      this.push = args.push;
    }
    if (args.httpStream !== undefined) {
      this.httpStream = args.httpStream;
    }
  }
};
SMessageTraffic.prototype = {};
SMessageTraffic.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.all = new SMessageTypes();
        this.all.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.realtime = new SMessageTypes();
        this.realtime.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.rest = new SMessageTypes();
        this.rest.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.push = new SMessageTypes();
        this.push.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRUCT) {
        this.httpStream = new SMessageTypes();
        this.httpStream.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SMessageTraffic.prototype.write = function(output) {
  output.writeStructBegin('SMessageTraffic');
  if (this.all !== undefined) {
    output.writeFieldBegin('all', Thrift.Type.STRUCT, 1);
    this.all.write(output);
    output.writeFieldEnd();
  }
  if (this.realtime !== undefined) {
    output.writeFieldBegin('realtime', Thrift.Type.STRUCT, 2);
    this.realtime.write(output);
    output.writeFieldEnd();
  }
  if (this.rest !== undefined) {
    output.writeFieldBegin('rest', Thrift.Type.STRUCT, 3);
    this.rest.write(output);
    output.writeFieldEnd();
  }
  if (this.push !== undefined) {
    output.writeFieldBegin('push', Thrift.Type.STRUCT, 4);
    this.push.write(output);
    output.writeFieldEnd();
  }
  if (this.httpStream !== undefined) {
    output.writeFieldBegin('httpStream', Thrift.Type.STRUCT, 5);
    this.httpStream.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

SRequestCount = function(args) {
  this.succeeded = undefined;
  this.failed = undefined;
  this.refused = undefined;
  if (args) {
    if (args.succeeded !== undefined) {
      this.succeeded = args.succeeded;
    }
    if (args.failed !== undefined) {
      this.failed = args.failed;
    }
    if (args.refused !== undefined) {
      this.refused = args.refused;
    }
  }
};
SRequestCount.prototype = {};
SRequestCount.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.DOUBLE) {
        this.succeeded = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.DOUBLE) {
        this.failed = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.DOUBLE) {
        this.refused = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SRequestCount.prototype.write = function(output) {
  output.writeStructBegin('SRequestCount');
  if (this.succeeded !== undefined) {
    output.writeFieldBegin('succeeded', Thrift.Type.DOUBLE, 1);
    output.writeDouble(this.succeeded);
    output.writeFieldEnd();
  }
  if (this.failed !== undefined) {
    output.writeFieldBegin('failed', Thrift.Type.DOUBLE, 2);
    output.writeDouble(this.failed);
    output.writeFieldEnd();
  }
  if (this.refused !== undefined) {
    output.writeFieldBegin('refused', Thrift.Type.DOUBLE, 3);
    output.writeDouble(this.refused);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

SStats = function(args) {
  this.all = undefined;
  this.inbound = undefined;
  this.outbound = undefined;
  this.persisted = undefined;
  this.connections = undefined;
  this.channels = undefined;
  this.apiRequests = undefined;
  this.tokenRequests = undefined;
  this.inProgress = undefined;
  this.count = undefined;
  if (args) {
    if (args.all !== undefined) {
      this.all = args.all;
    }
    if (args.inbound !== undefined) {
      this.inbound = args.inbound;
    }
    if (args.outbound !== undefined) {
      this.outbound = args.outbound;
    }
    if (args.persisted !== undefined) {
      this.persisted = args.persisted;
    }
    if (args.connections !== undefined) {
      this.connections = args.connections;
    }
    if (args.channels !== undefined) {
      this.channels = args.channels;
    }
    if (args.apiRequests !== undefined) {
      this.apiRequests = args.apiRequests;
    }
    if (args.tokenRequests !== undefined) {
      this.tokenRequests = args.tokenRequests;
    }
    if (args.inProgress !== undefined) {
      this.inProgress = args.inProgress;
    }
    if (args.count !== undefined) {
      this.count = args.count;
    }
  }
};
SStats.prototype = {};
SStats.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.all = new SMessageTypes();
        this.all.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.inbound = new SMessageTraffic();
        this.inbound.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.outbound = new SMessageTraffic();
        this.outbound.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.persisted = new SMessageTypes();
        this.persisted.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRUCT) {
        this.connections = new SConnectionTypes();
        this.connections.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.STRUCT) {
        this.channels = new SResourceCount();
        this.channels.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.STRUCT) {
        this.apiRequests = new SRequestCount();
        this.apiRequests.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.STRUCT) {
        this.tokenRequests = new SRequestCount();
        this.tokenRequests.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 10:
      if (ftype == Thrift.Type.STRING) {
        this.inProgress = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 11:
      if (ftype == Thrift.Type.I32) {
        this.count = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SStats.prototype.write = function(output) {
  output.writeStructBegin('SStats');
  if (this.all !== undefined) {
    output.writeFieldBegin('all', Thrift.Type.STRUCT, 1);
    this.all.write(output);
    output.writeFieldEnd();
  }
  if (this.inbound !== undefined) {
    output.writeFieldBegin('inbound', Thrift.Type.STRUCT, 2);
    this.inbound.write(output);
    output.writeFieldEnd();
  }
  if (this.outbound !== undefined) {
    output.writeFieldBegin('outbound', Thrift.Type.STRUCT, 3);
    this.outbound.write(output);
    output.writeFieldEnd();
  }
  if (this.persisted !== undefined) {
    output.writeFieldBegin('persisted', Thrift.Type.STRUCT, 4);
    this.persisted.write(output);
    output.writeFieldEnd();
  }
  if (this.connections !== undefined) {
    output.writeFieldBegin('connections', Thrift.Type.STRUCT, 5);
    this.connections.write(output);
    output.writeFieldEnd();
  }
  if (this.channels !== undefined) {
    output.writeFieldBegin('channels', Thrift.Type.STRUCT, 6);
    this.channels.write(output);
    output.writeFieldEnd();
  }
  if (this.apiRequests !== undefined) {
    output.writeFieldBegin('apiRequests', Thrift.Type.STRUCT, 7);
    this.apiRequests.write(output);
    output.writeFieldEnd();
  }
  if (this.tokenRequests !== undefined) {
    output.writeFieldBegin('tokenRequests', Thrift.Type.STRUCT, 8);
    this.tokenRequests.write(output);
    output.writeFieldEnd();
  }
  if (this.inProgress !== undefined) {
    output.writeFieldBegin('inProgress', Thrift.Type.STRING, 10);
    output.writeString(this.inProgress);
    output.writeFieldEnd();
  }
  if (this.count !== undefined) {
    output.writeFieldBegin('count', Thrift.Type.I32, 11);
    output.writeI32(this.count);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

SStatsArray = function(args) {
  this.items = undefined;
  if (args) {
    if (args.items !== undefined) {
      this.items = args.items;
    }
  }
};
SStatsArray.prototype = {};
SStatsArray.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        var _size48 = 0;
        var _rtmp352;
        this.items = [];
        var _etype51 = 0;
        _rtmp352 = input.readListBegin();
        _etype51 = _rtmp352.etype;
        _size48 = _rtmp352.size;
        for (var _i53 = 0; _i53 < _size48; ++_i53)
        {
          var elem54 = null;
          elem54 = new SStats();
          elem54.read(input);
          this.items.push(elem54);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SStatsArray.prototype.write = function(output) {
  output.writeStructBegin('SStatsArray');
  if (this.items !== undefined) {
    output.writeFieldBegin('items', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRUCT, this.items.length);
    for (var iter55 in this.items)
    {
      if (this.items.hasOwnProperty(iter55))
      {
        iter55 = this.items[iter55];
        iter55.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

WWebhookMessage = function(args) {
  this.name = undefined;
  this.webhookId = undefined;
  this.timestamp = undefined;
  this.serial = undefined;
  this.data = undefined;
  if (args) {
    if (args.name !== undefined) {
      this.name = args.name;
    }
    if (args.webhookId !== undefined) {
      this.webhookId = args.webhookId;
    }
    if (args.timestamp !== undefined) {
      this.timestamp = args.timestamp;
    }
    if (args.serial !== undefined) {
      this.serial = args.serial;
    }
    if (args.data !== undefined) {
      this.data = args.data;
    }
  }
};
WWebhookMessage.prototype = {};
WWebhookMessage.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.webhookId = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.timestamp = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.serial = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRUCT) {
        this.data = new TData();
        this.data.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

WWebhookMessage.prototype.write = function(output) {
  output.writeStructBegin('WWebhookMessage');
  if (this.name !== undefined) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 1);
    output.writeString(this.name);
    output.writeFieldEnd();
  }
  if (this.webhookId !== undefined) {
    output.writeFieldBegin('webhookId', Thrift.Type.STRING, 2);
    output.writeString(this.webhookId);
    output.writeFieldEnd();
  }
  if (this.timestamp !== undefined) {
    output.writeFieldBegin('timestamp', Thrift.Type.I64, 3);
    output.writeI64(this.timestamp);
    output.writeFieldEnd();
  }
  if (this.serial !== undefined) {
    output.writeFieldBegin('serial', Thrift.Type.STRING, 4);
    output.writeString(this.serial);
    output.writeFieldEnd();
  }
  if (this.data !== undefined) {
    output.writeFieldBegin('data', Thrift.Type.STRUCT, 5);
    this.data.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

WWebhookEnvelope = function(args) {
  this.error = undefined;
  this.items = undefined;
  if (args) {
    if (args.error !== undefined) {
      this.error = args.error;
    }
    if (args.items !== undefined) {
      this.items = args.items;
    }
  }
};
WWebhookEnvelope.prototype = {};
WWebhookEnvelope.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.error = new TError();
        this.error.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        var _size56 = 0;
        var _rtmp360;
        this.items = [];
        var _etype59 = 0;
        _rtmp360 = input.readListBegin();
        _etype59 = _rtmp360.etype;
        _size56 = _rtmp360.size;
        for (var _i61 = 0; _i61 < _size56; ++_i61)
        {
          var elem62 = null;
          elem62 = new WWebhookMessage();
          elem62.read(input);
          this.items.push(elem62);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

WWebhookEnvelope.prototype.write = function(output) {
  output.writeStructBegin('WWebhookEnvelope');
  if (this.error !== undefined) {
    output.writeFieldBegin('error', Thrift.Type.STRUCT, 1);
    this.error.write(output);
    output.writeFieldEnd();
  }
  if (this.items !== undefined) {
    output.writeFieldBegin('items', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRUCT, this.items.length);
    for (var iter63 in this.items)
    {
      if (this.items.hasOwnProperty(iter63))
      {
        iter63 = this.items[iter63];
        iter63.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};


var clientmessage_refs = {
	TAction: TAction,
	TFlags: TFlags,
	TType: TType,
	TError: TError,
	TData: TData,
	TPresence: TPresence,
	TMessage: TMessage,
	TChannelMessage: TChannelMessage,
	TProtocolMessage: TProtocolMessage,
	TPresenceState: TPresenceState,
	TMessageArray: TMessageArray
};

var EventEmitter = (function() {

	/* public constructor */
	function EventEmitter() {
		this.any = [];
		this.events = {};
		this.anyOnce = [];
		this.eventsOnce = {};
	}

	/**
	 * Add an event listener
	 * @param event (optional) the name of the event to listen to
	 *        if not supplied, all events trigger a call to the listener
	 * @param listener the listener to be called
	 */
	EventEmitter.prototype.on = function(event, listener) {
		if(arguments.length == 1 && typeof(event) == 'function') {
			this.any.push(event);
		} else if(event === null) {
			this.any.push(listener);
		} else {
			var listeners = this.events[event] = this.events[event] || [];
			listeners.push(listener);
		}
	};

	/**
	 * Remove one or more event listeners
	 * @param event (optional) the name of the event whose listener
	 *        is to be removed. If not supplied, the listener is
	 *        treated as an 'any' listener
	 * @param listener (optional) the listener to remove. If not
	 *        supplied, all listeners are removed.
	 */
	EventEmitter.prototype.off = function(event, listener) {
		if(arguments.length == 0) {
			this.any = [];
			this.events = {};
			this.anyOnce = [];
			this.eventsOnce = {};
			return;
		}
		if(arguments.length == 1) {
			if(typeof(event) == 'function') {
				/* we take this to be the listener and treat the event as "any" .. */
				listener = event;
				event = null;
			}
			/* ... or we take event to be the actual event name and listener to be all */
		}
		var listeners, idx = -1;
		if(event === null) {
			/* "any" case */
			if(listener) {
				if(!(listeners = this.any) || (idx = Utils.arrIndexOf(listeners, listener)) == -1) {
					if(listeners = this.anyOnce)
						idx = Utils.arrIndexOf(listeners, listener);
				}
				if(idx > -1)
					listeners.splice(idx, 1);
			} else {
				this.any = [];
				this.anyOnce = [];
			}
			return;
		}
		/* "normal* case where event is an actual event */
		if(listener) {
			var listeners, idx = -1;
			if(!(listeners = this.events[event]) || (idx = Utils.arrIndexOf(listeners, listener)) == -1) {
				if(listeners = this.eventsOnce[event])
					idx = Utils.arrIndexOf(listeners, listener);
			}
			if(idx > -1)
				listeners.splice(idx, 1);
		} else {
			delete this.events[event];
			delete this.eventsOnce[event];
		}
	};

	/**
	 * Get the array of listeners for a given event; excludes once events
	 * @param event (optional) the name of the event, or none for 'any'
	 * @return array of events, or null if none
	 */
	EventEmitter.prototype.listeners = function(event) {
		if(event) {
			var listeners = (this.events[event] || []);
			if(this.eventsOnce[event])
				Array.prototype.push.apply(listeners, this.eventsOnce[event]);
			return listeners.length ? listeners : null;
		}
		return this.any.length ? this.any : null;
	};

	/**
	 * Emit an event
	 * @param event the event name
	 * @param args the arguments to pass to the listener
	 */
	EventEmitter.prototype.emit = function(event  /* , args... */) {
		var args = Array.prototype.slice.call(arguments, 1);
		var eventThis = {event:event};

		/* wrap the try/catch in a function improves performance by 30% */
		function callListener(listener) {
			try { listener.apply(eventThis, args); } catch(e) {
				Logger.logAction(Logger.LOG_ERROR, 'EventEmitter.emit()', 'Unexpected listener exception: ' + e + '; stack = ' + e.stack);
			}
		}
		if(this.anyOnce.length) {
			var listeners = this.anyOnce;
			this.anyOnce = [];
			for(var i = 0; i < listeners.length; i++)
				callListener((listeners[i]));
		}
		for(var i = 0; i < this.any.length; i++)
			this.any[i].apply(eventThis, args);
		var listeners = this.eventsOnce[event];
		if(listeners) {
			delete this.eventsOnce[event];
			for(var i = 0; i < listeners.length; i++)
				callListener((listeners[i]));
		}
		var listeners = this.events[event];
		if(listeners)
			for(var i = 0; i < listeners.length; i++)
				callListener((listeners[i]));
	};

	/**
	 * Listen for a single occurrence of an event
	 * @param event the name of the event to listen to
	 * @param listener the listener to be called
	 */
	EventEmitter.prototype.once = function(event, listener) {
		if(arguments.length == 1 && typeof(event) == 'function') {
			this.anyOnce.push(event);
		} else if(event === null) {
			this.anyOnce.push(listener);
		} else {
			var listeners = this.eventsOnce[event] = (this.eventsOnce[event] || []);
			listeners.push(listener);
		}
	};

	return EventEmitter;
})();

var Logger = (function() {
	var noop = function() {};

	var LOG_NONE  = 0,
	LOG_ERROR = 1,
	LOG_MAJOR = 2,
	LOG_MINOR = 3,
	LOG_MICRO = 4;

	var LOG_DEFAULT = LOG_MINOR,
	LOG_DEBUG   = LOG_MICRO;

	var logLevel = LOG_MICRO;
	var logHandler = noop;

	/* public constructor */
	function Logger(args) {}

	/* public constants */
	Logger.LOG_NONE    = LOG_NONE,
	Logger.LOG_ERROR   = LOG_ERROR,
	Logger.LOG_MAJOR   = LOG_MAJOR,
	Logger.LOG_MINOR   = LOG_MINOR,
	Logger.LOG_MICRO   = LOG_MICRO;

	Logger.LOG_DEFAULT = LOG_DEFAULT,
	Logger.LOG_DEBUG   = LOG_DEBUG;

	/* public static functions */
	Logger.logAction = function(level, action, message) {
		if(level <= logLevel) {
			logHandler('Ably: ' + action + ': ' + message);
		}
	};

	Logger.setLog = function(level, handler) {
		logLevel = level || LOG_DEFAULT;
		logHandler = handler || function(msg) { console.log(msg); };
	};

	return Logger;
})();

var Multicaster = (function() {

	function Multicaster(members) {
		members = members || [];

		var handler = function() {
			for(var i = 0; i < members.length; i++) {
				var member = members[i];
				try { member.apply(null, arguments); } catch(e){} };
			};

		handler.push = function() {
			Array.prototype.push.apply(members, arguments);
		};
		return handler;
	};

	return Multicaster;
})();

var Utils = (function() {
	var isBrowser = (typeof(window) == 'object');

	function Utils() {}

	/*
	 * Add a set of properties to a target object
	 * target: the target object
	 * props:  an object whose enumerable properties are
	 *         added, by reference only
	 */
	Utils.addProperties = Utils.mixin = function(target, src) {
		for(var prop in src)
			target[prop] = src[prop];
		return target;
	};

	/*
	 * Add a set of properties to a target object
	 * target: the target object
	 * props:  an object whose enumerable properties are
	 *         added, by reference only
	 */
	Utils.copy = function(src) {
		return Utils.mixin({}, src);
	};

	/*
	 * Determine whether or not a given object is
	 * an array.
	 */
	Utils.isArray = function(ob) {
		return Object.prototype.toString.call(ob) == '[object Array]';
	};

	/*
	 * Determine whether or not an object contains
	 * any enumerable properties.
	 * ob: the object
	 */
	Utils.isEmpty = function(ob) {
		for(var prop in ob)
			return false;
		return true;
	};

	/*
	 * Perform a simple shallow clone of an object.
	 * Result is an object irrespective of whether
	 * the input is an object or array. All
	 * enumerable properties are copied.
	 * ob: the object
	 */
	Utils.shallowClone = function(ob) {
		var result = new Object();
		for(var prop in ob)
			result[prop] = ob[prop];
		return result;
	};

	/*
	 * Clone an object by creating a new object with the
	 * given object as its prototype. Optionally
	 * a set of additional own properties can be
	 * supplied to be added to the newly created clone.
	 * ob:            the object to be cloned
	 * ownProperties: optional object with additional
	 *                properties to add
	 */
	Utils.prototypicalClone = function(ob, ownProperties) {
		function F() {}
		F.prototype = ob;
		var result = new F();
		if(ownProperties)
			Utils.mixin(result, ownProperties);
		return result;
	};

	/*
	 * Declare a constructor to represent a subclass
	 * of another constructor
	 * See node.js util.inherits
	 */
	Utils.inherits = (typeof(require) !== 'undefined' && require('util').inherits) || function(ctor, superCtor) {
		ctor.super_ = superCtor;
		ctor.prototype = Utils.prototypicalClone(superCtor.prototype, { constructor: ctor });
	};

	/*
	 * Determine whether or not an object has an enumerable
	 * property whose value equals a given value.
	 * ob:  the object
	 * val: the value to find
	 */
	Utils.containsValue = function(ob, val) {
		for(var i in ob) {
			if(ob[i] == val)
				return true;
		}
		return false;
	};

	Utils.intersect = function(arr, ob) { return Utils.isArray(ob) ? Utils.arrIntersect(arr, ob) : Utils.arrIntersectOb(arr, ob); };

	Utils.isArray = Array.isArray ? Array.isArray : function(arr) { return Object.prototype.toString.call(arr) === '[object Array]'; };

	Utils.arrIntersect = function(arr1, arr2) {
		var result = [];
		for(var i = 0; i < arr1.length; i++) {
			var member = arr1[i];
			if(Utils.arrIndexOf(arr2, member) != -1)
				result.push(member);
		}
		return result;
	};

	Utils.arrIntersectOb = function(arr, ob) {
		var result = [];
		for(var i = 0; i < arr.length; i++) {
			var member = arr[i];
			if(member in ob)
				result.push(member);
		}
		return result;
	};

	Utils.arrSubtract = function(arr1, arr2) {
		var result = [];
		for(var i = 0; i < arr1.length; i++) {
			var element = arr1[i];
			if(Utils.arrIndexOf(arr2, element) == -1)
				result.push(element);
		}
		return result;
	};

	Utils.arrIndexOf = Array.prototype.indexOf
		? function(arr, elem, fromIndex) {
			return arr.indexOf(elem,  fromIndex);
		}
		: function(arr, elem, fromIndex) {
			fromIndex = fromIndex || 0;
			var len = arr.length;
			for(;fromIndex < len; fromIndex++) {
				if(arr[fromIndex] === elem) {
					return fromIndex;
				}
			}
			return -1;
		};

	/*
	 * Construct an array of the keys of the enumerable
	 * properties of a given object, optionally limited
	 * to only the own properties.
	 * ob:      the object
	 * ownOnly: boolean, get own properties only
	 */
	Utils.keysArray = function(ob, ownOnly) {
		var result = [];
		for(var prop in ob) {
			if(ownOnly && !ob.hasOwnProperty(prop)) continue;
			result.push(prop);
		}
		return result.length ? result : undefined;
	};

	/*
	 * Construct an array of the values of the enumerable
	 * properties of a given object, optionally limited
	 * to only the own properties.
	 * ob:      the object
	 * ownOnly: boolean, get own properties only
	 */
	Utils.valuesArray = function(ob, ownOnly) {
		var result = [];
		for(var prop in ob) {
			if(ownOnly && !ob.hasOwnProperty(prop)) continue;
			result.push(ob[prop]);
		}
		return result.length ? result : undefined;
	};

	Utils.nextTick = isBrowser ? function(f) { setTimeout(f, 0); } : process.nextTick;

	var contentTypes = {
		json:   'application/json',
		jsonp:  'application/javascript',
		xml:    'application/xml',
		html:   'text/html',
		thrift: 'application/x-thrift'
	};

	Utils.defaultGetHeaders = function(binary) {
		var accept = binary ? contentTypes.thrift + ',' + contentTypes.json : contentTypes.json;
		return {
			accept: accept
		};
	};

	Utils.defaultPostHeaders = function(binary) {
		var accept = binary ? contentTypes.thrift + ',' + contentTypes.json : contentTypes.json;
		return {
			accept: accept,
			'content-type': binary ? contentTypes.thrift : contentTypes.json
		};
	};

	Utils.arrRandomElement = function(arr) {
		return arr.splice(Math.floor(Math.random() * arr.length));
	};

	Utils.toQueryString = function(params) {
		var parts = [];
		if(params) {
			for(var key in params)
				parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));
		}
		return parts.length ? '?' + parts.join('&') : '';
	};

	Utils.parseQueryString = function(query) {
		var match,
			search = /([^?&=]+)=?([^&]*)/g,
			result = {};

		while (match = search.exec(query))
			result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);

 		return result;
	};

	return Utils;
})();

var Defaults = {
	protocolVersion:          1,
	HOST:                     'rest.ably.io',
	WS_HOST:                  'realtime.ably.io',
	FALLBACK_HOSTS:           ['A.ably-realtime.com', 'B.ably-realtime.com', 'C.ably-realtime.com', 'D.ably-realtime.com', 'E.ably-realtime.com'],
	PORT:                     80,
	TLS_PORT:                 443,
	connectTimeout:           15000,
	disconnectTimeout:        30000,
	suspendedTimeout:         120000,
	recvTimeout:              90000,
	sendTimeout:              10000,
	connectionPersistTimeout: 15000,
	httpTransports:           ['xhr', 'iframe', 'jsonp'],
	transports:               ['web_socket', 'flash_socket', 'xhr', 'iframe', 'jsonp'],
	flashTransport:           {swfLocation: (typeof window !== 'undefined' ? window.location.protocol : 'https:') + '//cdn.ably.io/lib/swf/WebSocketMainInsecure-0.9.swf'}
};

Defaults.getHost = function(options, host, ws) {
	host = host || options.host || Defaults.HOST;
	if(ws)
		host = ((host == options.host) && (options.wsHost || host))
			|| ((host == Defaults.HOST) && (Defaults.WS_HOST || host))
			|| host;
	return host;
};

Defaults.getPort = function(options, tls) {
	return (tls || options.tls) ? (options.tlsPort || Defaults.TLS_PORT) : (options.port || Defaults.PORT);
};

Defaults.getHosts = function(options) {
	var hosts;
	if(options.host) {
		hosts = [options.host];
		if(options.fallbackHosts)
			hosts.concat(options.fallbackHosts);
	} else {
		hosts = [Defaults.HOST].concat(Defaults.FALLBACK_HOSTS);
	}
	return hosts;
};

if (typeof exports !== 'undefined' && this.exports !== exports) {
	exports.defaults = Defaults;
}
var DomEvent = (function() {
	function DomEvent() {}

	DomEvent.addListener = function(target, event, listener) {
		if(target.addEventListener) {
			target.addEventListener(event, listener, false);
		} else {
			target.attachEvent('on'+event, listener);
		}
	};

	DomEvent.removeListener = function(target, event, listener) {
		if(target.removeEventListener) {
			target.removeEventListener(event, listener, false);
		} else {
			target.detachEvent('on'+event, listener);
		}
	};

	DomEvent.addMessageListener = function(target, listener) {
		DomEvent.addListener(target, 'message', listener);
	};

	DomEvent.removeMessageListener = function(target, listener) {
		DomEvent.removeListener(target, 'message', listener);
	};

	DomEvent.addUnloadListener = function(listener) {
		DomEvent.addListener(window, 'unload', listener);
	};

	return DomEvent;
})();
var XHRRequest = (function() {
	var noop = function() {};
	var idCounter = 0;
	var pendingRequests = {};

	/* duplicated here; because this is included standalone in iframe.js */
	var REQ_SEND = 0,
		REQ_RECV = 1,
		REQ_RECV_POLL = 2,
		REQ_RECV_STREAM = 3;

	function clearPendingRequests() {
		for(var id in pendingRequests)
			pendingRequests[id].dispose();
	}

	var isIE = window.XDomainRequest;
	var xhrSupported, xdrSupported;
	function isAvailable() {
		if(window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()) {
			return (xhrSupported = true);
		}

		if(isIE && document.domain && (window.location.protocol == 'https:')) {
			return (xdrSupported = true);
		}

		return false;
	};

	function responseHeaders(xhr) {
		var headers = {};
		if(xhr.getResponseHeader) {
			var contentType = xhr.getResponseHeader('Content-Type');
			if(contentType)
				headers['Content-Type'] = contentType;
		}
		return headers;
	}

	function XHRRequest(uri, headers, params, body, requestMode) {
		EventEmitter.call(this);
		params = params || {};
		params.rnd = String(Math.random()).substr(2);
		this.uri = uri + Utils.toQueryString(params);
		this.headers = headers || {};
		this.body = body;
		this.requestMode = requestMode;
		this.requestComplete = false;
		pendingRequests[this.id = String(++idCounter)] = this;
	}
	Utils.inherits(XHRRequest, EventEmitter);
	XHRRequest.isAvailable = isAvailable;

	var createRequest = XHRRequest.createRequest = function(uri, headers, params, body, requestMode) {
		return xhrSupported ? new XHRRequest(uri, headers, params, body, requestMode) : new XDRRequest(uri, headers, params, body, requestMode);
	};

	XHRRequest.prototype.complete = function(err, body) {
		if(!this.requestComplete) {
			this.requestComplete = true;
			var xhr = this.xhr;
			if(body)
				this.emit('data', body);
			this.emit('complete', err, body, (xhr && responseHeaders(xhr)));
			this.dispose();
		}
	};

	XHRRequest.prototype.abort = function() {
		this.dispose();
	};

	XHRRequest.prototype.exec = function() {
		var timeout = (this.requestMode == REQ_SEND) ? Defaults.sendTimeout : Defaults.recvTimeout,
			timer = this.timer = setTimeout(function() { xhr.abort(); }, timeout),
			body = this.body,
			method = body ? 'POST' : 'GET',
			contentType = 'application/json',
			headers = this.headers,
			xhr = this.xhr = new XMLHttpRequest(),
			self = this;

		headers['accept'] = (headers['accept'] || contentType);
		if(body) {
			if(typeof(body) == 'object') body = JSON.stringify(body);
			headers['content-type'] = (headers['content-type'] || contentType);
		}

		xhr.open(method, this.uri, true);
		xhr.withCredentials = 'true';
		for(var h in headers)
			xhr.setRequestHeader(h, headers[h]);

		var onerror = xhr.onerror = function(err) {
			err.code = 80000;
			self.complete(err);
		};
		xhr.onabort = function() {
			var err = new Error('Request cancelled');
			err.statusCode = 400;
			onerror(err);
		};
		xhr.ontimeout = function() {
			var err = new Error('Request timed out');
			err.statusCode = 408;
			onerror(err);
		};

		var streaming,
			statusCode,
			responseBody,
			successResponse,
			streamPos = 0;

		function onResponse() {
			clearTimeout(timer);
			successResponse = (statusCode < 400);
			if(statusCode == 204) {
				self.complete();
				return;
			}
			streaming = (self.requestMode == REQ_RECV_STREAM && successResponse);
		}

		function onEnd() {
			try {
				responseBody = xhr.responseText;
				if(!responseBody || !responseBody.length) {
					if(status != 204) {
						err = new Error('Incomplete response body from server');
						err.statusCode = 400;
						self.complete(err);
					}
					return;
				}
				responseBody = JSON.parse(String(responseBody));
			} catch(e) {
				var err = new Error('Malformed response body from server: ' + e.message);
				err.statusCode = 400;
				self.complete(err);
				return;
			}

			if(successResponse) {
				self.complete(null, responseBody);
				return;
			}

			var err = responseBody.error;
			if(!err) {
				err = new Error('Error response received from server: ' + statusCode);
				err.statusCode = statusCode;
			}
			self.complete(err);
		}

		function onProgress() {
			responseBody = xhr.responseText;
			var bodyEnd = responseBody.length - 1, idx, chunk;
			while((streamPos < bodyEnd) && (idx = responseBody.indexOf('\n', streamPos)) > -1) {
				chunk = responseBody.slice(streamPos, idx);
				streamPos = idx + 1;
				onChunk(chunk);
			}
		}

		function onChunk(chunk) {
			try {
				chunk = JSON.parse(chunk);
			} catch(e) {
				err = new Error('Malformed response body from server: ' + e.message);
				err.statusCode = 400;
				self.complete(err);
				return;
			}
			self.emit('data', chunk);
		}

		function onStreamEnd() {
			onProgress();
			self.streamComplete = true;
			Utils.nextTick(function() {
				self.complete();
			});
		}

		xhr.onreadystatechange = function() {
			var readyState = xhr.readyState;
			if(readyState < 3) return;
			if(xhr.status !== 0) {
				if(statusCode === undefined) {
					statusCode = xhr.status;
					/* IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450 */
					if(statusCode === 1223) statusCode = 204;
					onResponse();
				}
				if(readyState == 3 && streaming) {
					onProgress();
				} else if(readyState == 4) {
					if(streaming)
						onStreamEnd();
					else
						onEnd();
				}
			}
		};
		xhr.send(body);
	};

	XHRRequest.prototype.dispose = function() {
		var xhr = this.xhr;
		if(xhr) {
			xhr.onreadystatechange = xhr.onerror = xhr.onabort = xhr.ontimeout = noop;
			this.xhr = null;
			var timer = this.timer;
			if(timer) {
				clearTimeout(timer);
				this.timer = null;
			}
			if(!this.requestComplete)
				xhr.abort();
		}
		delete pendingRequests[this.id];
	};

	function XDRRequest(uri, headers, params, body, requestMode) {
		params.ua = 'xdr';
		XHRRequest.call(this, uri, headers, params, body, requestMode);
	}
	Utils.inherits(XDRRequest, XHRRequest);

   /**
	* References:
	* http://ajaxian.com/archives/100-line-ajax-wrapper
	* http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx
	*/
	XDRRequest.prototype.exec = function() {
		var timeout = (this.requestMode == REQ_SEND) ? Defaults.sendTimeout : Defaults.recvTimeout,
			timer = this.timer = setTimeout(function() { xhr.abort(); }, timeout),
			body = this.body,
			method = body ? 'POST' : 'GET',
			xhr = this.xhr = new XDomainRequest(),
			self = this;

		if(body)
			if(typeof(body) == 'object') body = JSON.stringify(body);

		var onerror = xhr.onerror = function() {
			Logger.logAction(Logger.LOG_ERROR, 'Request.onerror()', '');
			var err = new Error('Error response');
			err.statusCode = 400;
			err.code = 80000;
			self.complete(err);
		};
		xhr.onabort = function() {
			Logger.logAction(Logger.LOG_ERROR, 'Request.onabort()', '');
			var err = new Error('Request cancelled');
			err.statusCode = 400;
			onerror(err);
		};
		xhr.ontimeout = function() {
			Logger.logAction(Logger.LOG_ERROR, 'Request.timeout()', '');
			var err = new Error('Request timed out');
			err.statusCode = 408;
			onerror(err);
		};

		var streaming,
			statusCode,
			responseBody,
			streamPos = 0;

		function onResponse() {
			clearTimeout(timer);
			responseBody = xhr.responseText;
			//Logger.logAction(Logger.LOG_MICRO, 'onResponse: ', responseBody);
			if(responseBody) {
				var idx = responseBody.length - 1;
				if(responseBody[idx] == '\n' || (idx = responseBody.indexOf('\n') > -1)) {
					var chunk = responseBody.slice(0, idx);
					try {
						chunk = JSON.parse(chunk);
						var err = chunk.error;
						if(err) {
							statusCode = err.statusCode || 500;
							self.complete(err);
						} else {
							statusCode = responseBody ? 201 : 200;
							streaming = (self.requestMode == REQ_RECV_STREAM);
							if(streaming) {
								streamPos = idx;
								if(!Utils.isEmpty(chunk)) {
									self.emit('data', chunk);
								}
							}
						}
					} catch(e) {
						err = new Error('Malformed response body from server: ' + e.message);
						err.statusCode = 400;
						self.complete(err);
						return;
					}
				}
			}
		}

		function onEnd() {
			try {
				responseBody = xhr.responseText;
				//Logger.logAction(Logger.LOG_MICRO, 'onEnd: ', responseBody);
				if(!responseBody || !responseBody.length) {
					if(status != 204) {
						err = new Error('Incomplete response body from server');
						err.statusCode = 400;
						self.complete(err);
					}
					return;
				}
				responseBody = JSON.parse(String(responseBody));
			} catch(e) {
				var err = new Error('Malformed response body from server: ' + e.message);
				err.statusCode = 400;
				self.complete(err);
				return;
			}
			self.complete(null, responseBody);
		}

		function onProgress() {
			responseBody = xhr.responseText;
			//Logger.logAction(Logger.LOG_MICRO, 'onProgress: ', responseBody);
			var bodyEnd = responseBody.length - 1, idx, chunk;
			while((streamPos < bodyEnd) && (idx = responseBody.indexOf('\n', streamPos)) > -1) {
				chunk = responseBody.slice(streamPos, idx);
				streamPos = idx + 1;
				onChunk(chunk);
			}
		}

		function onChunk(chunk) {
			try {
				chunk = JSON.parse(chunk);
			} catch(e) {
				err = new Error('Malformed response body from server: ' + e.message);
				err.statusCode = 400;
				self.complete(err);
				return;
			}
			self.emit('data', chunk);
		}

		function onStreamEnd() {
			onProgress();
			self.streamComplete = true;
			Utils.nextTick(function() {
				self.complete();
			});
		}

		xhr.onprogress = function() {
			if(statusCode === undefined)
				onResponse();
			else if(streaming)
				onProgress();
		};

		xhr.onload = function() {
			if(statusCode === undefined) {
				onResponse();
				if(self.requestComplete)
					return;
			}
			if(streaming)
				onStreamEnd();
			else
				onEnd();
		};

		try {
			xhr.open(method, this.uri);
			xhr.send(body);
		} catch(e) {
			Logger.logAction(Logger.LOG_ERROR, 'Request.onStreamEnd()', 'Unexpected send exception; err = ' + e);
			onerror(e);
		}
	};

	XDRRequest.prototype.dispose = function() {
		var xhr = this.xhr;
		if(xhr) {
			xhr.onprogress = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = noop;
			this.xhr = null;
			var timer = this.timer;
			if(timer) {
				clearTimeout(timer);
				this.timer = null;
			}
			if(!this.requestComplete)
				xhr.abort();
		}
		delete pendingRequests[this.id];
	};

	var isAvailable = XHRRequest.isAvailable();
	if(isAvailable) {
		DomEvent.addUnloadListener(clearPendingRequests);
		if(typeof(Http) !== 'undefined') {
			Http.supportsAuthHeaders = xhrSupported;
			Http.Request = function(uri, headers, params, body, binary, callback) {
				var req = createRequest(uri, headers, params, body, REQ_SEND);
				req.once('complete', callback);
				req.exec();
				return req;
			};
		}
	}

	return XHRRequest;
})();

(function() {
	var origin = location.origin || location.protocol + "//" + location.hostname + (location.port ? ':' + location.port: '');
	var connectParams = Utils.parseQueryString(window.location.search);
	var parentOrigin = connectParams.origin;
	delete connectParams.origin;
	var authParams = ('access_token' in connectParams) ? {access_token: connectParams.access_token} : {key_id: connectParams.key_id, key_value:connectParams.key_value};
	var parentWindow = window.parent;
	var messagetypes = clientmessage_refs;
	var actions = messagetypes.TAction;

	//Logger.setLog(4);

	var REQ_SEND = 0,
		REQ_RECV = 1,
		REQ_RECV_POLL = 2,
		REQ_RECV_STREAM = 3;

	function encodeRequest(requestItems) {
		if(typeof(requestItems) != 'string')
			requestItems = JSON.stringify(requestItems);
		return requestItems;
	}

	function decodeResponse(responseData) {
		if(typeof(responseData) == 'string')
			responseData = JSON.parse(responseData);
		return responseData;
	}

	function errorMessage(err) {
		return new messagetypes.TProtocolMessage({
			action: actions.ERROR,
			error: err
		});
	}

	function responseMessage(err, message) {
		if(err) {
			var errMessage = errorMessage(err);
			if(message)
				Utils.mixin(errMessage, message);
			message = errMessage;
		}
		return message;
	}

	function IframeAgent() {
		/* streaming defaults to true */
		this.stream = ('stream' in connectParams) ? connectParams.stream : true;
		this.sendRequest = null;
		this.recvRequest = null;
		this.pendingCallback = null;
		this.pendingItems = null;
		this.baseUri = this.sendUri = this.recvUri = null;

		var self = this;
		DomEvent.addMessageListener(window, function(ev) {self.onMessageEvent(ev.data); })
	}

	IframeAgent.prototype.connect = function() {
		var baseUri = this.baseUri = origin + '/comet/',
			connectUri = baseUri + 'connect',
			self = this;

		Logger.logAction(Logger.LOG_MINOR, 'IframeAgent.connect()', 'uri: ' + connectUri);

		/* this will be the 'recvRequest' so this connection can stream messages */
		var connectRequest = this.recvRequest = XHRRequest.createRequest(connectUri, null, connectParams, null, (this.stream ? REQ_RECV_STREAM : REQ_RECV));

		connectRequest.on('data', function(data) {
			/* intercept initial responses until connectionId obtained */
			if(self.sendUri == null)
				self.checkConnectResponse(data);
			self.onData(data);
		});
		connectRequest.on('complete', function(err) {
			self.recvRequest = null;
			if(err) {
				self.postErrorEvent(err);
				return;
			}
		});
		connectRequest.exec();
	};

	IframeAgent.prototype.dispose = function() {
		if(this.recvRequest) {
			this.recvRequest.abort();
			this.recvRequest = null;
		}
	};

	IframeAgent.prototype.checkConnectResponse = function(responseData) {
		try {
			var items = decodeResponse(responseData);
			if(items && items.length)
				for(var i = 0; i < items.length; i++) {
					var message = items[i];
					if(message.action == actions.CONNECTED) {
						this.onConnect(message);
						break;
					}
				}
		} catch (e) {
			Logger.logAction(Logger.LOG_ERROR, 'IframeAgent.checkConnectResponse()', 'Unexpected exception handing channel event: ' + e);
		}
	};

	IframeAgent.prototype.onConnect = function(message) {
		var baseConnectionUri =  this.baseUri + message.connectionId;
		Logger.logAction(Logger.LOG_MICRO, 'IframeAgent.onConnect()', 'baseUri = ' + baseConnectionUri);
		this.sendUri = baseConnectionUri + '/send';
		this.recvUri = baseConnectionUri + '/recv';

		var self = this;
		Utils.nextTick(function() {
			self.recv();
		})
	};

	IframeAgent.prototype.onMessageEvent = function(data) {
		var self = this;
		this.send(decodeResponse(data), function(err, response) {
			if(err) {
				self.postErrorEvent(err);
				return;
			}
			if(response)
				self.postMessageEvent(response);
		});
	};

	IframeAgent.prototype.send = function(msg, callback) {
		Logger.logAction(Logger.LOG_MICRO, 'IframeAgent.send()', 'msg = ' + JSON.stringify(msg));
		if(this.sendRequest) {
			/* there is a pending send, so queue this message */
			this.pendingItems = this.pendingItems || [];
			this.pendingItems.push(msg);

			this.pendingCallback = this.pendingCallback || Multicaster();
			this.pendingCallback.push(callback);
			return;
		}
		/* send this, plus any pending, now */
		var pendingItems = this.pendingItems || [];
		pendingItems.push(msg);
		this.pendingItems = null;

		var pendingCallback = this.pendingCallback;
		if(pendingCallback) {
			pendingCallback.push(callback);
			callback = pendingCallback;
			this.pendingCallback = null;
		}

		this.sendItems(pendingItems, callback);
	};

	IframeAgent.prototype.sendItems = function(items, callback) {
		var sendUri = this.sendUri,
			self = this;

		if(!sendUri) {
			callback({message:'Unable to send; not connected', code:80000, statusCode:400});
			return;
		}

		var sendRequest = this.sendRequest = XHRRequest.createRequest(sendUri, null, authParams, encodeRequest(items), REQ_SEND);
		sendRequest.on('complete', function(err, data) {
			if(err) Logger.logAction(Logger.LOG_ERROR, 'IframeAgent.sendItems()', 'on complete: err = ' + err);
			self.sendRequest = null;
			if(data) self.onData(data);

			var pendingItems = self.pendingItems;
			if(pendingItems) {
				self.pendingItems = null;
				var pendingCallback = self.pendingCallback;
				self.pendingCallback = null;
				Utils.nextTick(function() {
					self.sendItems(pendingItems, pendingCallback);
				});
			}
			callback(err);
		});
		sendRequest.exec();
	};

	IframeAgent.prototype.recv = function() {
		/* do nothing if there is an active request, which might be streaming */
		if(this.recvRequest)
			return;

		/* If we're no longer connected, do nothing */
		if(!this.isConnected)
			return;

		var self = this,
			recvRequest = this.recvRequest = XHRRequest.createRequest(this.recvUri, null, authParams, null, (self.stream ? REQ_RECV_STREAM : REQ_RECV_POLL));

		recvRequest.on('data', function(data) {
			self.onData(data);
		});
		recvRequest.on('complete', function(err) {
			self.recvRequest = null;
			if(err) {
				self.postErrorEvent(err);
				return;
			}
			Utils.nextTick(function() {
				self.recv();
			});
		});
		recvRequest.exec();
	};

	IframeAgent.prototype.onData = function(responseData) {
		this.postMessageEvent(responseData);
	};

	IframeAgent.prototype.postMessageEvent = function(items) {
		parentWindow.postMessage(encodeRequest(items), parentOrigin);
	};

	IframeAgent.prototype.postErrorEvent = function(err, message) {
		var item = responseMessage(err, message);
		this.postMessageEvent([item]);
	};

	(new IframeAgent()).connect();
})();



})();
